<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.数据结构入门 | 笔记</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="学习笔记">
    
    <link rel="preload" href="/notes/assets/css/0.styles.c7fa5e28.css" as="style"><link rel="preload" href="/notes/assets/js/app.b857b8fe.js" as="script"><link rel="preload" href="/notes/assets/js/2.9c1da7be.js" as="script"><link rel="preload" href="/notes/assets/js/15.8cf68992.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.8b66e410.js"><link rel="prefetch" href="/notes/assets/js/11.721abe74.js"><link rel="prefetch" href="/notes/assets/js/12.1091a66b.js"><link rel="prefetch" href="/notes/assets/js/13.5ed55a7f.js"><link rel="prefetch" href="/notes/assets/js/14.98cd348c.js"><link rel="prefetch" href="/notes/assets/js/16.8dfea44e.js"><link rel="prefetch" href="/notes/assets/js/17.e2025bb2.js"><link rel="prefetch" href="/notes/assets/js/3.3e3da40a.js"><link rel="prefetch" href="/notes/assets/js/4.0026ad61.js"><link rel="prefetch" href="/notes/assets/js/5.2d62cdf3.js"><link rel="prefetch" href="/notes/assets/js/6.42d5c628.js"><link rel="prefetch" href="/notes/assets/js/7.05146a6d.js"><link rel="prefetch" href="/notes/assets/js/8.15249e07.js"><link rel="prefetch" href="/notes/assets/js/9.d8ec63d3.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.c7fa5e28.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><!----> <span class="site-name">笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>1.数据结构入门</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_1-1-什么是数据结构" class="sidebar-link">1.1.什么是数据结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_1-2-数据结构的存储类型" class="sidebar-link">1.2.数据结构的存储类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_1-2-1-线性表" class="sidebar-link">1.2.1.线性表</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_1-2-2-树存储结构" class="sidebar-link">1.2.2.树存储结构</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_1-2-3-图存储结构" class="sidebar-link">1.2.3.图存储结构</a></li></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-1-数组" class="sidebar-link">2.1.数组</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-2-链表" class="sidebar-link">2.2.链表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-2-1-单链表" class="sidebar-link">2.2.1.单链表</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-2-2-循环链表" class="sidebar-link">2.2.2.循环链表</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-2-3-双向链表" class="sidebar-link">2.2.3.双向链表</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-2-4-双循环链表" class="sidebar-link">2.2.4.双循环链表</a></li></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-3-栈" class="sidebar-link">2.3.栈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-3-1-栈简介" class="sidebar-link">2.3.1.栈简介</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-3-2-栈的实现" class="sidebar-link">2.3.2.栈的实现</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-3-3-栈的常见应用场景" class="sidebar-link">2.3.3.栈的常见应用场景</a></li></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-4-队列" class="sidebar-link">2.4.队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-4-1-队列简介" class="sidebar-link">2.4.1.队列简介</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-4-2-队列分类" class="sidebar-link">2.4.2.队列分类</a></li><li class="sidebar-sub-header"><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_2-4-3-常见的应用场景" class="sidebar-link">2.4.3.常见的应用场景</a></li></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_3-1-树的概括" class="sidebar-link">3.1.树的概括</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_3-2-二叉树" class="sidebar-link">3.2.二叉树</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_3-3-二叉搜索树" class="sidebar-link">3.3.二叉搜索树</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_3-4-平衡搜索树" class="sidebar-link">3.4.平衡搜索树</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_3-5-b树" class="sidebar-link">3.5.B树</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_3-6-b-树" class="sidebar-link">3.6.B+树</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#_4-1-图的概述" class="sidebar-link">4.1.图的概述</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_1-数据结构入门"><a href="#_1-数据结构入门" class="header-anchor">#</a> 1.数据结构入门</h1> <h2 id="_1-1-什么是数据结构"><a href="#_1-1-什么是数据结构" class="header-anchor">#</a> 1.1.什么是数据结构</h2> <p>数据结构 (data structure) 是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p> <p>数据结构是学习数据存储方式的一门学科。直白地理解，就是研究数据的存储方式，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用”。</p> <h2 id="_1-2-数据结构的存储类型"><a href="#_1-2-数据结构的存储类型" class="header-anchor">#</a> 1.2.数据结构的存储类型</h2> <p>数据结构大致包含以下几种存储结构：</p> <ul><li>线性表：主要包括顺序表、链表、栈、队列；</li> <li>树结构：主要包括普通树、二叉树、线索二叉树等；</li> <li>图存储结构；</li></ul> <h3 id="_1-2-1-线性表"><a href="#_1-2-1-线性表" class="header-anchor">#</a> 1.2.1.线性表</h3> <p>在线性数据结构中，元素以非分层方式存储，除了第一个和最后一个元素，它的每个元素具有后继元素和前导元素。</p> <p>线性表结构存储的数据往往是可以依次排列的，就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。</p> <p>线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。</p> <h4 id="_1-2-1-1-顺序表"><a href="#_1-2-1-1-顺序表" class="header-anchor">#</a> 1.2.1.1.顺序表</h4> <p>顺序表，简单地理解，就是常用的数组（由于顺序表结构的底层实现借助的就是数组，因此对于初学者来说，可以把顺序表完全等价为数组，但实则不是这样。数据结构是研究数据存储方式的一门学科，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型，并不属于数据结构的范畴）。</p> <p>使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的。</p> <h4 id="_1-2-1-2-链表"><a href="#_1-2-1-2-链表" class="header-anchor">#</a> 1.2.1.2.链表</h4> <p>使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL）。</p> <h4 id="_1-2-1-3-栈和队列"><a href="#_1-2-1-3-栈和队列" class="header-anchor">#</a> 1.2.1.3.栈和队列</h4> <p>栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。</p> <ul><li>栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈；</li> <li>队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列；</li></ul> <h3 id="_1-2-2-树存储结构"><a href="#_1-2-2-树存储结构" class="header-anchor">#</a> 1.2.2.树存储结构</h3> <p>树存储结构适合存储具有“一对多”关系的数据。</p> <p>比如张三只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。</p> <h3 id="_1-2-3-图存储结构"><a href="#_1-2-3-图存储结构" class="header-anchor">#</a> 1.2.3.图存储结构</h3> <p>图存储结构适合存储具有“多对多”关系的数据。</p> <h1 id="_2-线性数据结构"><a href="#_2-线性数据结构" class="header-anchor">#</a> 2.线性数据结构</h1> <h2 id="_2-1-数组"><a href="#_2-1-数组" class="header-anchor">#</a> 2.1.数组</h2> <p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p> <p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p> <p>数组可以随机访问数组的元素，因为可使用给定的基址和数据元素的大小来计算数组的每个元素的地址。</p> <p>如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的。</p> <div class="language-java extra-class"><pre class="language-java"><code>假如数组的长度为 n。
访问：<span class="token class-name">O</span>（<span class="token number">1</span>）<span class="token comment">//访问特定位置的元素</span>
插入：<span class="token class-name">O</span>（n ）<span class="token comment">//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时</span>
删除：<span class="token class-name">O</span>（n）<span class="token comment">//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时</span>
</code></pre></div><p>数组的时间复杂度</p> <table><thead><tr><th style="text-align:center;">操作</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">访问</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">搜索</td> <td style="text-align:center;">O(n)</td></tr> <tr><td style="text-align:center;">插入</td> <td style="text-align:center;">O(n)</td></tr> <tr><td style="text-align:center;">删除</td> <td style="text-align:center;">O(n)</td></tr></tbody></table> <p>数组的空间复杂度</p> <p>在数组中，最坏情况下的空间复杂度是O(n)。</p> <h2 id="_2-2-链表"><a href="#_2-2-链表" class="header-anchor">#</a> 2.2.链表</h2> <p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p> <p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p> <p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p> <p><strong>常见链表分类：</strong></p> <ul><li>单链表</li> <li>双向链表</li> <li>循环链表</li> <li>双向循环链表</li></ul> <div class="language- extra-class"><pre class="language-text"><code>假如链表中有n个元素。
访问：O（n）//访问特定位置的元素
插入删除：O（1）//必须要要知道插入元素的位置
</code></pre></div><p>链表的时间复杂度</p> <table><thead><tr><th style="text-align:center;">操作</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">访问</td> <td style="text-align:center;">θ(n)</td></tr> <tr><td style="text-align:center;">搜索</td> <td style="text-align:center;">θ(n)</td></tr> <tr><td style="text-align:center;">插入</td> <td style="text-align:center;">θ(1)</td></tr> <tr><td style="text-align:center;">删除</td> <td style="text-align:center;">θ(1)</td></tr></tbody></table> <h3 id="_2-2-1-单链表"><a href="#_2-2-1-单链表" class="header-anchor">#</a> 2.2.1.单链表</h3> <p><strong>单链表</strong> 只有一个方向，结点只有一个后继指针 next  指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head  节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p> <h3 id="_2-2-2-循环链表"><a href="#_2-2-2-循环链表" class="header-anchor">#</a> 2.2.2.循环链表</h3> <p>**循环链表 **其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p> <h3 id="_2-2-3-双向链表"><a href="#_2-2-3-双向链表" class="header-anchor">#</a> 2.2.3.双向链表</h3> <p><strong>双向链表</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p> <h3 id="_2-2-4-双循环链表"><a href="#_2-2-4-双循环链表" class="header-anchor">#</a> 2.2.4.双循环链表</h3> <p><strong>双向循环链表</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p> <h2 id="_2-3-栈"><a href="#_2-3-栈" class="header-anchor">#</a> 2.3.栈</h2> <h3 id="_2-3-1-栈简介"><a href="#_2-3-1-栈简介" class="header-anchor">#</a> 2.3.1.栈简介</h3> <p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p> <p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p> <div class="language-java extra-class"><pre class="language-java"><code>假设堆栈中有n个元素。
访问：<span class="token class-name">O</span>（n）<span class="token comment">//最坏情况</span>
插入删除：<span class="token class-name">O</span>（<span class="token number">1</span>）<span class="token comment">//顶端插入和删除元素</span>
</code></pre></div><table><thead><tr><th style="text-align:center;">操作</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">添加</td> <td style="text-align:center;">o(1)</td></tr> <tr><td style="text-align:center;">删除</td> <td style="text-align:center;">on)</td></tr> <tr><td style="text-align:center;">搜索</td> <td style="text-align:center;">o(n)</td></tr></tbody></table> <h3 id="_2-3-2-栈的实现"><a href="#_2-3-2-栈的实现" class="header-anchor">#</a> 2.3.2.栈的实现</h3> <p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p> <p>栈需要具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p> <h3 id="_2-3-3-栈的常见应用场景"><a href="#_2-3-3-栈的常见应用场景" class="header-anchor">#</a> 2.3.3.栈的常见应用场景</h3> <h4 id="_2-3-3-1浏览器的前进和后退功能"><a href="#_2-3-3-1浏览器的前进和后退功能" class="header-anchor">#</a> 2.3.3.1浏览器的前进和后退功能</h4> <p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把  1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从  Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到  Stack1 中。</p> <h4 id="_2-3-3-2-检查符号是否成对出现"><a href="#_2-3-3-2-检查符号是否成对出现" class="header-anchor">#</a> 2.3.3.2.检查符号是否成对出现</h4> <blockquote><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串，判断该字符串是否有效。</p> <p>有效字符串需满足：</p> <ol><li>左括号必须用相同类型的右括号闭合。</li> <li>左括号必须以正确的顺序闭合。</li></ol> <p>比如 &quot;()&quot;、&quot;()[]{}&quot;、&quot;{[]}&quot; 都是有效字符串，而 &quot;(]&quot; 、&quot;([)]&quot; 则不是。</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 括号之间的对应规则</span>
    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> mappings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mappings<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> topElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'#'</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>topElement <span class="token operator">!=</span> mappings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-3-3-3-反转字符串"><a href="#_2-3-3-3-反转字符串" class="header-anchor">#</a> 2.3.3.3.反转字符串</h4> <p>将字符串中的每个字符先入栈再出栈就可以了。</p> <h4 id="_2-3-3-4-维护函数调用"><a href="#_2-3-3-4-维护函数调用" class="header-anchor">#</a> 2.3.3.4.维护函数调用</h4> <p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p> <h2 id="_2-4-队列"><a href="#_2-4-队列" class="header-anchor">#</a> 2.4.队列</h2> <h3 id="_2-4-1-队列简介"><a href="#_2-4-1-队列简介" class="header-anchor">#</a> 2.4.1.队列简介</h3> <p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>假设队列中有n个元素。
访问：<span class="token class-name">O</span>（n）<span class="token comment">//最坏情况</span>
插入删除：<span class="token class-name">O</span>（<span class="token number">1</span>）<span class="token comment">//后端插入前端删除元素</span>
</code></pre></div><p>队列的时间复杂度</p> <h3 id="_2-4-2-队列分类"><a href="#_2-4-2-队列分类" class="header-anchor">#</a> 2.4.2.队列分类</h3> <h4 id="_2-4-2-1-单队列"><a href="#_2-4-2-1-单队列" class="header-anchor">#</a> 2.4.2.1.单队列</h4> <p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p> <p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p> <p>假设一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。</p> <h4 id="_2-4-2-2-循环队列"><a href="#_2-4-2-2-循环队列" class="header-anchor">#</a> 2.4.2.2.循环队列</h4> <p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p> <h3 id="_2-4-3-常见的应用场景"><a href="#_2-4-3-常见的应用场景" class="header-anchor">#</a> 2.4.3.常见的应用场景</h3> <ul><li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li> <li><strong>线程池中的请求/任务队列：</strong>  线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li> <li>Linux 内核进程队列（按优先级排队）</li> <li>现实生活中的派对，播放器上的播放列表;</li> <li>消息队列</li></ul> <h1 id="_3-树"><a href="#_3-树" class="header-anchor">#</a> 3.树</h1> <h2 id="_3-1-树的概括"><a href="#_3-1-树的概括" class="header-anchor">#</a> 3.1.树的概括</h2> <p>树是一种递归数据结构，包含一个或多个数据节点的集合，其中一个节点被指定为树的根，而其余节点被称为根的子节点。</p> <p>除根节点之外的节点被划分为非空集，其中每个节点将被称为子树。</p> <p>树的节点要么保持它们之间的父子关系，要么它们是姐妹节点。</p> <p>在通用树中，一个节点可以具有任意数量的子节点，但它只能有一个父节点。</p> <h4 id="基本术语"><a href="#基本术语" class="header-anchor">#</a> 基本术语</h4> <ul><li><strong>根节点</strong> ： 根节点是树层次结构中的最顶层节点。 换句话说，根节点是没有任何父节点的节点。</li> <li><strong>子树</strong>： 如果根节点不为空，则树<code>T1</code>，<code>T2</code>和<code>T3</code>称为根节点的子树。</li> <li><strong>叶节点</strong>： 树的节点，没有任何子节点，称为叶节点。 叶节点是树的最底部节点。 一般树中可以存在任意数量的叶节点。 叶节点也可以称为外部节点。</li> <li><strong>路径</strong>： 连续边的序列称为路径。 在上图所示的树中，节点<code>E</code>的路径为<code>A→B→E</code>。</li> <li><strong>祖先节点</strong>： 节点的祖先是从根到该节点的路径上的任何前节点。根节点没有祖先节点。 在上图所示的树中，节点<code>F</code>的祖先是<code>B</code>和<code>A</code>。</li> <li><strong>度</strong>： 节点的度数等于子节点数，节点数。 在上图所示的树中，节点<code>B</code>的度数为<code>2</code>。叶子节点的度数总是<code>0</code>，而在完整的二叉树中，每个节点的度数等于<code>2</code>。</li> <li><strong>级别编号</strong>： 为树的每个节点分配一个级别编号，使得每个节点都存在于高于其父级的一个级别。树的根节点始终是级别<code>0</code>。</li></ul> <h2 id="_3-2-二叉树"><a href="#_3-2-二叉树" class="header-anchor">#</a> 3.2.二叉树</h2> <p>二叉树是一种特殊类型的通用树，它的每个节点最多可以有两个子节点。 二叉树通常被划分为三个不相交的子集。</p> <h2 id="_3-3-二叉搜索树"><a href="#_3-3-二叉搜索树" class="header-anchor">#</a> 3.3.二叉搜索树</h2> <h2 id="_3-4-平衡搜索树"><a href="#_3-4-平衡搜索树" class="header-anchor">#</a> 3.4.平衡搜索树</h2> <h2 id="_3-5-b树"><a href="#_3-5-b树" class="header-anchor">#</a> 3.5.B树</h2> <p>B树是一种专用的M阶树，可广泛用于磁盘访问。 M阶树顺序的B树最多可以有<code>m-1</code>个键和M个子树。 使用B树的主要原因之一是它能够在单个节点中存储大量键，并且通过保持树的高度相对较小来存储大键值。</p> <p>排序M的B树包含M阶树的所有属性。 此外，它还包含以下属性。</p> <ul><li>B树中的每个节点最多包含<code>m</code>个子节点。</li> <li>除根节点和叶节点外，B树中的每个节点至少包含<code>m/2</code>个子节点。</li> <li>根节点必须至少有<code>2</code>个节点。</li> <li>所有叶节点必须处于同一级别。</li></ul> <p>所有节点都不必包含相同数量的子节点，但每个节点必须具有<code>m/2</code>个节点数。</p> <h2 id="_3-6-b-树"><a href="#_3-6-b-树" class="header-anchor">#</a> 3.6.B+树</h2> <p>B+树是B树的扩展，允许有效的插入，删除和搜索操作。</p> <p>在B树中，键和记录都可以存储在内部节点和叶子节点中。 然而，在B+树中，记录(数据)只能存储在叶节点上，而内部节点只能存储键值。</p> <p>B+树的叶节点以单链表的形式链接在一起，以使搜索查询更有效。</p> <p>B+树用于存储无法存储在主存储器中的大量数据。 由于主存储器的大小总是有限的事实，B+树的内部节点(访问记录的键)存储在主存储器中，而叶节点存储在辅助存储器中。</p> <h1 id="_4-图"><a href="#_4-图" class="header-anchor">#</a> 4.图</h1> <h2 id="_4-1-图的概述"><a href="#_4-1-图的概述" class="header-anchor">#</a> 4.1.图的概述</h2> <p>图是相对复杂的一种数据结构，由顶点和连接每对顶点的边所构成的图形就是图。</p> <p>图可以看作是循环树，图中顶点(节点)维持它们之间的任何复杂关系，而不是简单的父子关系。</p> <p>图中的圆圈叫作“顶点”(Vertex，也叫“结点”)，连接顶点的线叫作“边”（Edge）。也就是说，由顶点和连接每对顶点的边所构成的图形就是图。 图按照顶点指向的方向可分为无向图和有向图，像我上面的就叫无向图。 图在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构。常见的图遍历算法就是广度优先算法和深度优先算法。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.b857b8fe.js" defer></script><script src="/notes/assets/js/2.9c1da7be.js" defer></script><script src="/notes/assets/js/15.8cf68992.js" defer></script>
  </body>
</html>
